// routes/ai.js
import express from "express";
import openai from "../../lib/openaiClient.js";
import {fetchRepoContents} from "../../lib/githubClient.js"
import RepoPost from "../../models/RepoPost.js";
import RepoContext from "../models/RepoContext.js";
import { aiLimiter } from "../../middleware/aiRateLimiter.js";

const router = express.Router();

/**
 * POST /SERVER_URI/ai/analyze-repo/:repoPostId
 * Body optional: {force: boolean} // force reanalysis
 */
router.post("/:repoPostId", aiLimiter, async (req, res) => {
  try {
    const { repoPostId } = req.params;
    const repoPost = await RepoPost.findById(repoPostId).populate("user");
    if (!repoPost) return res.status(404).json({ error: "RepoPost not found" });

    // optional: prevent duplicate auto runs unless forced
    const existing = await RepoContext.findOne({ repoPost: repoPostId });
    if (existing && !req.body.force) {
      return res.status(200).json({ message: "Already analyzed", repoContext: existing });
    }

    // fetch repo content
    const { aggregated, owner, repo } = await fetchRepoContents(repoPost.githubUrl);

    // Build prompt â€” instruct model to return JSON only
    const systemPrompt = `You are an expert software engineer + reviewer. 
Given the repository content and the repo metadata, produce a JSON object EXACTLY matching the schema described below. Do not return any explanation outside JSON. If a field is not applicable, set it to an empty string or null or an empty array, as appropriate.

Schema:
{
  "aiSummary": "string",
  "suggestions": ["string"],
  "beatingPercentage": number,        // 0-100 (if unknown, set 0; we'll compute later)
  "strengths": ["string"],
  "improvements": ["string"],
  "codeStyleFeedback": {
     "structure":"string",
     "naming":"string",
     "comments":"string",
     "designPattern":"string",
     "uiConsistency":"string",
     "userExperience":"string"
  },
  "metrics": {
     "efficiencyScore": number,
     "scalabilityScore": number,
     "designQualityScore": number,
     "creativityScore": number,
     "userExperienceScore": number,
     "readabilityScore": number,
     "maintainabilityScore": number,
     "documentationScore": number
  },
  "experienceLevel":"beginner|intermediate|advanced|expert"
}`;

    const userPrompt = `REPO METADATA:
title: ${repoPost.title}
description: ${repoPost.description}
githubUrl: ${repoPost.githubUrl}
owner: ${owner || ""}
repo: ${repo || ""}
---- REPOSITORY FILES (truncated) ----
${aggregated.slice(0, 15000)}
---- END ----
Analyze the repository and fill all fields. Keep numbers between 0 and 100. Return JSON only.`;

    // call OpenAI (chat or responses endpoint). using Chat Completions / Responses
    const start = Date.now();
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini", // choose appropriate model for cost/perf
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt }
      ],
      temperature: 0.0,
      max_tokens: 1500,
    });

    const processingTime = Date.now() - start;
    // Extract response text (depends on SDK shape)
    const rawText = response.choices?.[0]?.message?.content ?? response.choices?.[0]?.text ?? "";
    // Try parse JSON
    let parsed;
    try {
      parsed = JSON.parse(rawText);
    } catch (err) {
      // fallback: try to extract JSON substring
      const jsonMatch = rawText.match(/\{[\s\S]*\}/);
      if (jsonMatch) parsed = JSON.parse(jsonMatch[0]);
      else throw new Error("AI did not return valid JSON. Response: " + rawText.slice(0, 1000));
    }

    // Map parsed -> RepoContext document
    const repoContextData = {
      repoPost: repoPost._id,
      user: repoPost.user._id,
      aiSummary: parsed.aiSummary || parsed.summary || "No summary provided",
      suggestions: parsed.suggestions || [],
      strengths: parsed.strengths || [],
      improvements: parsed.improvements || [],
      codeStyleFeedback: parsed.codeStyleFeedback || {},
      metrics: parsed.metrics || {},
      experienceLevel: parsed.experienceLevel || "beginner",
      beatingPercentage: parsed.beatingPercentage || 0, // we'll recompute below
      aiMetadata: {
        model: "gpt-4o-mini",
        temperature: 0.0,
        processingTime,
        tokensUsed: response.usage?.total_tokens ?? 0,
        createdAt: new Date(),
      },
      isAutoGenerated: true,
    };

    // Save (upsert)
    let repoContext = await RepoContext.findOneAndUpdate(
      { repoPost: repoPost._id },
      repoContextData,
      { upsert: true, new: true, setDefaultsOnInsert: true }
    );

    // Compute beatingPercentage: compare overallScore to others
    // Note: RepoContext pre-save calculates overallScore. We should recompute by fetching scores from DB:
    const allScores = await RepoContext.find({}).select("overallScore");
    const total = allScores.length;
    const betterCount = allScores.filter(r => (r.overallScore ?? 0) < (repoContext.overallScore ?? 0)).length;
    const beating = total > 0 ? Math.round((betterCount / total) * 100) : 0;

    repoContext.beatingPercentage = beating;
    await repoContext.save();

    return res.json({ success: true, repoContext });

  } catch (err) {
    console.error("AI analyze error:", err);
    return res.status(500).json({ error: err.message || "Server error" });
  }
});

export default router;
