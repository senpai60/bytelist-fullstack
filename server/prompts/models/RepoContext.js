import mongoose from "mongoose";

const repoContextSchema = new mongoose.Schema(
  {
    // ðŸ”— Link to RepoPost
    repoPost: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "RepoPost",
      required: true,
    },

    // ðŸ‘¤ User who submitted this repo
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },

    // ðŸ§  AI-generated summary (main required insight)
    aiSummary: {
      type: String,
      required: true,
      trim: true,
    },

    // ðŸ” Actionable suggestions (always required)
    suggestions: {
      type: [String],
      required: true,
      default: [],
    },

    // ðŸ§® Beating percentage (how well user performed)
    beatingPercentage: {
      type: Number,
      required: true,
      min: 0,
      max: 100,
      default: 0,
    },

    // ðŸ’¡ Strengths / highlights (optional)
    strengths: {
      type: [String],
      default: [],
    },

    // âš ï¸ Weaknesses or improvement areas
    improvements: {
      type: [String],
      default: [],
    },

    // ðŸ’¬ Code & design style feedback
    codeStyleFeedback: {
      structure: { type: String, default: "" },
      naming: { type: String, default: "" },
      comments: { type: String, default: "" },
      designPattern: { type: String, default: "" },
      uiConsistency: { type: String, default: "" },
      userExperience: { type: String, default: "" },
    },

    // âš™ï¸ Evaluation metrics (dynamic for all project types)
    metrics: {
      // âš¡ For algorithmic or backend performance
      efficiencyScore: { type: Number, min: 0, max: 100, default: 0 },
      scalabilityScore: { type: Number, min: 0, max: 100, default: 0 },

      // ðŸŽ¨ For design, UI/UX, frontend logic
      designQualityScore: { type: Number, min: 0, max: 100, default: 0 },
      creativityScore: { type: Number, min: 0, max: 100, default: 0 },
      userExperienceScore: { type: Number, min: 0, max: 100, default: 0 },

      // ðŸ§© For structure and maintainability
      readabilityScore: { type: Number, min: 0, max: 100, default: 0 },
      maintainabilityScore: { type: Number, min: 0, max: 100, default: 0 },
      documentationScore: { type: Number, min: 0, max: 100, default: 0 },
    },

    // ðŸ Final aggregated rating
    overallScore: {
      type: Number,
      min: 0,
      max: 100,
      default: 0,
    },

    // ðŸ·ï¸ AI classification (skill tier)
    experienceLevel: {
      type: String,
      enum: ["beginner", "intermediate", "advanced", "expert"],
      default: "beginner",
    },

    // ðŸ§© AI processing metadata
    aiMetadata: {
      model: { type: String, default: "gpt-4o-mini" }, // e.g., gpt-4o, gpt-5
      temperature: { type: Number, default: 0.7 },
      processingTime: { type: Number, default: 0 }, // milliseconds
      tokensUsed: { type: Number, default: 0 },
      createdAt: { type: Date, default: Date.now },
    },

    // ðŸ§¾ Audit & review info
    lastReviewedByAI: { type: Date, default: Date.now },
    isAutoGenerated: { type: Boolean, default: true },
    humanVerified: { type: Boolean, default: false },
  },
  { timestamps: true }
);

// ðŸš€ Auto-calculate overallScore before save
repoContextSchema.pre("save", function (next) {
  const m = this.metrics;
  const scores = Object.values(m).filter(
    (s) => typeof s === "number" && !isNaN(s) && s > 0
  );
  this.overallScore =
    scores.length > 0
      ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length)
      : 0;
  next();
});

export default mongoose.model("RepoContext", repoContextSchema);
